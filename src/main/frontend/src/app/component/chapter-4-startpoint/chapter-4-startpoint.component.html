
<mat-card>
  <div class="row">
    <app-chapter-title [title]="'Chapter 4 - Data Binding'" ></app-chapter-title>
    <hr>
    <ul>
      <li class="sub-chapter">
        <h3>데이터 바인딩(Data Binding) 기초</h3>
        <p>
          <strong><em>데이터 바인딩</em></strong>이란 데이터를 컴포넌트 화면과 연결(sending data from component to view or vice versa)하는 기능이다.
          지금까지 챕터를 읽어왔다면, 우리는 이미 데이터 바인딩을 목격해왔다.
        </p>

        <app-code [code]="codes[0].code" [title]="codes[0].title"></app-code>

        <hr>
        <mat-card>
          <mat-card-title><h4>Try</h4></mat-card-title>
          <app-chapter4-1></app-chapter4-1>
        </mat-card>
        <hr> <br/>
        <p>
          앵귤러에서 데이터 바인딩의 방향은 <strong>단반향(one-directional)과 양방향(bi-directional)</strong>이 있다.
          단방향은 컴포넌트의 데이타가 뷰로 향하거나, 화면의 발생한 <em>event</em>가 컴포넌트의 핸들러로 향하는 것을 의미한다.<br/>
          앵귤러는 양방향 데이터 바인딩(two-way data binding)을 권장하지 않는다. 하지만 요구 사항에 따라 구현할 수 있다.
        </p>


      </li>

      <li class="sub-chapter">
        <h3>이벤트 바인딩(event binding)</h3>
        <p>
          이벤트 바인딩이란 특정 이벤트를 컴포넌트의 함수(event handler in component)에 연결함을 의미한다.
          템플릿(template)에서 이벤트 이름을 괄호("()") 로 감싸는 문법을 사용한다.
        </p>


        <hr>
        <mat-card>
          <mat-card-title><h4>Try</h4></mat-card-title>
          <app-chapter4-1-1></app-chapter4-1-1>
        </mat-card>
        <hr><br/>

        <app-code [code]="codes[1].code" [title]="codes[1].title"></app-code>

        <p>클라이언트에 의해 이벤트가 발생할때마다 이벤트 핸들러 함수는 다시 발동되므로 데이타의 흐름은
          <em>뷰에서 컴포넌트</em>로 흐르게 된다. 데이터는 이벤트 객체에 넣어 보낼 수 있으며, 이벤트 객체는 <code>$event</code>으로 컴포넌트에 전달할 수 있다.</p>
      </li>

      <li class="sub-chapter">
        <h3>프러퍼티와 속성 바인딩(Property and Attribute Binding)</h3>
        <p>
          <strong>프러퍼티</strong> 자바스크립트의 DOM을 표현하는 객체(ex HTMLInputElement)의 프러퍼티(value,required)를 의미한다.<br/>
          반면, <strong>속성</strong>은 HTML에 정의된 태그의 값이며 프러퍼티가 곧 HTML의 태그의 값으로 바인딩 되기에 대부분은 프로퍼티를 사용하면 된다.
          단, 특정 지원하지 않은 속성이 있을 경우 속성 바인딩이 요구되는 상황이 있으니 알아두자. <br/>
          프러퍼티와 속성을 구분하기 위해 앵귤러에서는 속성 바인딩을 <code>[attr.value]</code>와 같은 형식으로 규정했다.
        </p>
        <app-code [code]="codes[2].code" [title]="codes[2].title"></app-code>

        <app-chapter4-1-2></app-chapter4-1-2>

        <p>코드를 실행해보면 프러퍼티를 제외한 속성과 컴포넌트의 프러퍼티는 변하지 않는데 이유는 기본적으로
        데이터 바인딩은 <strong>단방향(one-directional)</strong>이기 때문이다.</p>
      </li>

      <li class="sub-chapter">
        <h3>템플릿 바인딩(Template Binding)</h3>
        <p>DOM 트리(Dom Tree)에서 엘리먼트(element)을 <strong>제거하거나 추가</strong> 싶다면 어떻게 할까?<br>
        앵귤레어서는 <code>NgIf, NgFor, NgSwitch</code> 등을 제공하며 이를 구조 디렉티브(structural directives)라고 부른다.
          이 디렉티브를 이용하면 특정 조건(expression for condition), 배열(array) 을 이용하며 엘리멘트를 추가하거나 제거할 수 있다.
          예제를 보면서 <code>NgIf, NgFor, NgSwitch</code>의 사용법을 살펴보자.
        </p>

        <app-code [code]="codes[3].code" [title]="codes[3].title"></app-code>

        <app-chapter-4-2></app-chapter-4-2>
      </li>

      <li class="sub-chapter">
        <h3>양방향 바인딩(two-way data binding)</h3>
        <p> <strong>양방향 바인딩</strong>은 단방향 두개를 조합한 것이다.
        단방향 두개를 조합 <em>(event -> component),(component -> dom property)</em> 하면 양방향이 되지만
        편의성을 위해 앵귤러는 <code>NgModel</code>이란 디렉티브를 제공한다.
        </p>

        <p style="border: 1px solid black; margin-top: 15px;margin-bottom: 15px;height: 35px">
          <code [innerText]="'<input [(ngModel)]=\'componetProperty\'>'" > </code>
        </p>

        <p>
          양방향 바인딩은 폼 필드의 값과 모델 객체의 값이 일치해야되는 폼에서 주로 사용되며, 성능에 영향이 크기 때문에
          꼭 필요한 상황에만 사용하도록 하자.
        </p>

        <app-code [code]="codes[4].code" [title]="codes[4].title"></app-code>

        <app-code [code]="codes[5].code" [title]="codes[5].title"></app-code>
        <app-chapter-4-3></app-chapter-4-3>
      </li>

      <li class="sub-chapter">
        <h3>옵저버블(Observable)</h3>
        <p>
          <strong>반응형 프로그래밍(Reactive Programming)</strong>은
          <strong>스트림(stream)</strong>을 <strong>구독(subscribe)</strong>하고, 스트림을 알맞게 가공하여 그것에 반응하는 방식의
          어플리케이션을 만드는 것을 의미한다.<br/>
          <a href="http://reactivex.io/rxjs/">RxJS</a>는 <strong>옵저버/옵저버블(observer/obserable)</strong>의 디자인 패턴(design pattern)을 모티브로 한
          스트림 지원 라이브러리 중 하나이며, 앵귤어 내부에 많이 통합되어 있어 사용하기 좋다.
        </p>
        <br>
        <p>
          <strong>옵저버블</strong> 연속된 데이터 스트림을 생성하는 객체이며, <strong>옵저버</strong> 이 스트림을 구독(subscription)하는 객체다.
          A 객체가 스트림을 생성하고 B가 이를 구독한다면, A는 Observable이며 B는 Observer이다.
        </p>

        <app-code [code]="codes[6].code" [title]="codes[6].title"></app-code>

        <p>
          옵저버 객체는 세 가지 콜백 함수<code>next,error,onComplete</code>를 가지고 있는데 next 는 다음 엘리멘터를 처리할 함수, error는 구독 중 에러 발생시 처리할 함수,
          데이터 스트림을 모두 소비(consume)하고 실행할 함수가 있다.<br/>
          또한 스트림은 절달될대 가공될 수 있으며, 그때는 <code>map(),filter()</code>등을 사용하면 된다.
        </p>

        <p>
          옵저버블을 알아봤으니, 이벤트를 옵저버블을 사용하여 핸들링하는 방법을 알아보자. 아래는 옵저버블 없이 이벤트를 처리하는 방법이다.<br/>
          <strong>이벤트(event)</strong>는 자바스크립트에서는 <code>Event</code> 객체로 표현되며, 이벤트가 어떤것인지, 어디서, 발생했는지에
          대한 정보를 가지고 있다. Template에서 $event를 전달하면, 이벤트 핸들러 함수는 이벤트 정보가 들어있는 Event 객체를 받을 수 있다.<br>
          또한 엘리멘트에서 <strong>템플릿 지역 변수(Local template variable)</strong> 사용하여 엘리먼트의 프러퍼티에 바로 접근도 가능하다.
        </p>
        <app-code [code]="codes[7].code" [title]="codes[7].title" ></app-code>

        <p>
          비동기적으로 발생하는 이벤트를 옵저버블로 처리하기 위해서는 <code>FormControl</code> 클래스의 <code>valueChanges</code>을
          사용하면 되는데 <code>valueChanges</code>는 <strong>이벤트를 옵저버블 스트림</strong> 리턴한다.

        </p>

        <app-code [code]="codes[8].code" [title]="codes[8].title" ></app-code>

        <app-chapter-4-4></app-chapter-4-4>

        <h3>구독 취소하기(Cancelling subscription)</h3>
        <hr>
        <p>
          옵저버블은 프로미스와 달리 동작이 완료되기 전에 <strong>취소</strong>할 수 있다.
          취소를 할 수 있다는 것은 이벤트 핸들러의 동작 중, 클라이언트가 다른 이벤트를 발생한다면
          전의 이벤트의 요청을 중단하고 새로운 이벤트 핸들러를 동작시킴을 의미한다.
          구독을 취소함으로써 서버에 불필요한 요청을 보내지 않으므로 성능상 큰 이점을 가져올 수 있다.
        </p>

        <app-code [code]="codes[9].code" [title]="codes[9].title" ></app-code>
        <app-chapter-4-4-1></app-chapter-4-4-1>
      </li>

      <li class="sub-chapter">
        <h3>파이프 (Pipe)</h3>
        <p>
          <strong>파이프</strong>는 어떤 값을 뷰로 보낼때 가공하기위해 사용하는 템플릿 엘리먼트이다.
          파이프의 기호는 리눅스(linux)와 같이 <strong>|</strong> 기호를 사용하며, 기호 뒤에 파이프 이름을 명시하면 된다.<br>
          아래는 자주 쓰이는 파이프의 종류이다.
        </p>
        <ul>
          <li><code>UpperCasePipe</code> :  | uppercase </li>
          <li><code>DatePipe</code> :  | date </li>
          <li><code>CurrencyPipe</code> :  | uppercase </li>
          <li><code>JsonPipe</code> :  | uppercase </li>
          <li><code>AsyncPipe</code> :  | uppercase </li>
        </ul>

        <br>
        <p>
          다음의 예제를 보자.
        </p>

        <app-code  [code]="'\{\{ myDate | date : \'medium\' | uppercase \}\}'"></app-code>

        <p>{{ date | date : 'medium' | uppercase }}</p>

        <br>
        <p>
          파이프에 인자기 있을 수도 있고, 없을수도 있으며 원하는 만큼 메서드 체이닝(method chanining)이 가능하다
          또한 개발자에 의한 <strong>커스텀 파이프</strong> 정의도 가능하며 방법은 아래와 같다.
        </p>

        <app-code [code]="codes[10].code" [title]="codes[10].title" ></app-code>

      </li>

    </ul>

  </div>
</mat-card>
